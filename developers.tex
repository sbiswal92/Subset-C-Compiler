\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{color}
\usepackage{url}


\newcommand{\TBD}[1]{{\color{blue}{\bf TBD:} #1}}


\begin{document}

\section{Part 4: Code Generation} 

\url{https://github.com/sbiswal92/Compiler540/releases/tag/Part4}
\\~
\\~This documentation describes the overall design for code generation. The objective of this project part is to define the \texttt{code} for each expression in the source file based on the operators and operands of the expression.
  
\subsection{Features}
\label{Features}
\begin{enumerate}
\item Generates the constant, globals, number of functions and function header
\item Handles Function calls
\item Has 2 built-in functions : \texttt{int getchar()} and  \texttt{int putchar(int c)}
\item Translates Unary operators - and \texttt{\~}
\item Translates binary arithmetic and bitwise operators. Translates casting.
\item Translates assignment operators and (pre- \& post-) increment \& decrement operators.
\item Stores string literals as constant separately 
\item Passes only arrays as parameter to functions, which can be initialized before passing as function parameters. N.B Passing string literals as function parameter is not working
\item Translates assignments operations, increment \& decrement to arrays
\end{enumerate}


\subsection{Design}

The parser is a single source file \texttt{parser.y} with dependencies on lexer, symbol table, abstract syntax tree and type checker.  The abstract syntax tree is same as before except that the node objects of type \texttt{expNode} in the AST now contain a new string-type property \texttt{code}, which stores the code for each expression.
 \\~
\\The code-generator works in 2 passes :
\begin{enumerate}
\item Pass 1: Reads through the source files to :
\begin{enumerate} 
\item Retrieve the number of constants and their values. These are then stored in a separate location with their code of the form \texttt{Cn} and their respective values.
\item Retrieve the number of global variables and their values. These are inserted into the global symbol table and their code is stored in the form of  \texttt{Gn}
\item Create the identifier symbols for built-in functions. These are inserted into the global symbol table at function number \texttt{0} and \texttt{1}, so that during function calls these do get detected.
\item Retrieve the number of remaining functions and their names. These are inserted into the global symbol table.
\item For each of the defined functions parameters and local variables informations are also pushed into their respective function-symbol table
\item The lexer is modified to return hex-code for all literals instead of their integer, float or string values.
\end{enumerate}
\item After Pass 1, the non-instruction output is printed.
\item Pass 2: Generates code for each expression based on the variable and literal symbols that have been already stored in the symbol tables(s). 
\end{enumerate}


\subsubsection{Code Generation}
This section summarizes one of the sections for generating code :
Code for assignment operator \texttt{=, +=, -= , *=,  /=, \%=} 
\\~
\\A typical  expression containing assignment operator looks like : \texttt{ left\_operand  = right\_operand}. This can have multiple sub-cases in terms of data-types and/or formats. Here the combination of different formats is discussed i.e literal, identifier or array. 
\\~For Left operand, \texttt{Lcode}:
\begin{itemize}
\item left\_operand cannot be a literal :
\item left\_operand is an identifier : \texttt{Lk}
\item left\_operand is an array, let  A[i] where A is referred as Lk in the symbol Table :  \texttt{push i; push Lk}
 \end{itemize}
 ~For Right operand,  \texttt{Rcode}:
\begin{itemize}
\item right\_operand is a literal, of some value \texttt{0x4572} : \texttt{pushv 0x4572}
\item right\_operand is an identifier :   \texttt{push Lk}
\item right\_operand  is an array, let B[i] of type `t' where B is referred as Lj in the symbol Table : \texttt{push i; push Lj; pusht[]; }
 \end{itemize}
~Final Code depends upon the operator, if it is \texttt{=} \& left is non-array
\begin{verbatim}
Rcode
copy
pop Lcode
popx
\end{verbatim}
~Final Code depends upon the operator, if it is \texttt{=} \& left is array type
\begin{verbatim}
Lcode
Rcode
popt[] ; Lk[i] = Rcode = Lj[i]
\end{verbatim}
~Final Code depends upon the operator, if it is \texttt{+=} \& left is non-array type
\begin{verbatim}
push Lcode
Rcode
+t
copy
pop Lcode
popx
\end{verbatim}
~Final Code depends upon the operator, if it is \texttt{+=} \& left is array type
\begin{verbatim}
Lcode  			 	; i, Lk
Rcode  			 	; Lj[i]
Lcode
pusht[]    ; Lk[i]
+t  			 	    ; Lj[i] + Lk[i]
popt[]  			 	; Lk[i] = Lj[i] + Lk[i]
\end{verbatim}

All codes containing identifiers that are pushed as operands into an expression are pass through \texttt{push}, al literals are passed via \texttt{pushv}. 


\end{document}