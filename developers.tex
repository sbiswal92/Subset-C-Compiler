\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{color}
\usepackage{url}


\newcommand{\TBD}[1]{{\color{blue}{\bf TBD:} #1}}


\begin{document}

\section{Part 1: Parser} 

\url{https://github.com/sbiswal92/Compiler540/releases/tag/Part2}
\\~
\\~This documentation describes the overall design of the parser. It also describes the data structure used to implement Symbol Table. The objective of this parser is to check the syntactic correctness of a C-language based source code and keep track of variable and function declarations.

\subsection{Features}
\label{Features}
\begin{enumerate}
\item Checks syntax for the subset C language
\item Handles one input file on command line
\item Variable scoping :
\begin{enumerate}
\item Lists the function declarations and global variables present in the input file.
\item Lists the parameters of the function and its local variables
\item Any variable enclosed within nested statement block of function definition body are listed as local variable of the function. 
\item Syntax checking for identifying variable re-declaration for all variables are traced based on their scope of declaration.
\end{enumerate}
\end{enumerate}


\subsection{Design}

The parser is a single source file \texttt{parser.y} with dependencies on lexer and symbol table.  
\begin{enumerate}
\item Lexer : \texttt{lexer.l} identifies the tokens and provides these to the parser that checks if the sequence of tokens in the file are syntactically correct
\item SymbolTable : This data structure is used to keep track of various function and variable declarations throughout the file. The table classifies the different kinds of declarations present within a given a scope. A symbol table is maintained for every different scope of declaration.
\item Parser : The parser defines the grammar that should be maintained among the tokens to mimic a valid C program. It also takes care of identifying the different kinds of declarations based on their syntax and populates the symbol table. Again based on the syntax, the parser is capable of identifying global, local and nested scopes.
\end{enumerate}


\subsubsection{Symbol Table}
The symbol table has following components :
\begin{enumerate}
\item Symbol : \texttt{symbol.h, symbol.c}
\\Each symbol is a representative of an identifier from the source code. It is defined as a \texttt{struct} datatype. A symbol is comprised of two properties \texttt{<name,kind>}, where name is the \texttt{name} of the identifier and \texttt{kind} tells if the identifier is a variable, function or parameter. Major helper functions defined for the symbol are :
\begin{enumerate}
\item To create a symbol from its parameters : \texttt{initializeSymbol(symbol, name, type)}
\item Identify if two symbols are same :  \texttt{symbolcmp(symbol1, symbol2)}
\item Print the contents of a symbol :   \texttt{printSymbol(symbol)}
\end{enumerate}

\item SymbolList : \texttt{symbolList.h, symbolList.c}
\\All symbols within a scope are stored in a linked list. For any given scope, its list contains all the identifiers that have been read by the parser so far. SymbolList is implemented as a linked list of \texttt{struct}. Major helper functions defined for symboList are meant for:
\begin{enumerate}
\item Insertion of a symbol into a list  : \texttt{symbolList\_insertEntry(symbolList, symbol)}
\item Print all symbols, variables, parameters or functions of a list
\end{enumerate}


\item SymbolTable : \texttt{symbolTable.h, symbolTable.c}
\\ Every scope maintains its own list of SymbolTable. The global scope has one SymbolTable in its list. A local scope may have more than on SymbolTable based on the number of equal-depth statement blocks present in the scope. SymbolTable is a \texttt{struct} comprising of :
\begin{enumerate}
\item SymbolList : To identify the list of identifiers that belong to this scope.
\item Parent SymbolTable : To identify the predecessor scope, so as to detect re-declaration of variables within this scope if it exists in parent; to identify availability of a variable if it exists in parent etc.
\item Children SymbolTables' List : To keep track of the nested scopes that are defined in the current scope for detecting variable re-declaration, variable access etc.
\end{enumerate}
Major helper functions associated with symbolTable and symbolTableList are meant for:
\begin{enumerate}
\item Creation of symbolTable and insertion of symbolTable into its scope list.
\\\texttt{initializeSymbolTableEntry(); 
\\symbolTableList\_insertEntry(symbolTable, symbolTableList)};
\item Insertion of symbol or symbolList into symbolTable.
\item Entrance into a new scope leading to creation of new child symbolTable and setting it as current worskpace. 
\texttt{enter\_scope(symbolTable)}
\item Exiting from old scope leading to setting the parent symbolTable as the current workspace.
\texttt{exit\_scope(symbolTable)}
\item Depth-first printing of symbolTable : \texttt{printAllLists(symbolTable)}
\end{enumerate}
\end{enumerate}

\subsubsection{Parser-SymbolTable Interaction}
\label{FS}
The communication between the parser and symbol table can be summarized as follows:
\begin{enumerate}
\item The parser begins with creation of an empty symbol table, pertaining to global scope.
\item When the parser detects a variable declaration, the variable name from the grammar is used to create a symbol of type variable and insert it to the current symbol table.
\item  When the parser detects a function declaration, the function name from the grammar is used to create a symbol of type function and insert it to the current symbol table. Also a new child symbol table is created and set as current workspace.
\begin{enumerate}
\item The parameters of this function scope are detected by the parser and inserted into the table.
\item The local variables of this scope are detected by the parser and inserted into the table.
\item Incase of existence of statement blocks, a new symbol table is created and set as workspace. 
\item When the parser detects end of statement block, scope is exited and parent table is set as workspace.
\item Step (b), (c) and (d) are repeated until function scope ends.
\end{enumerate}
\item Step 2 and 3 is repeated until end of file
\item Finally, the symbol table is dumped to print the contents.
\end{enumerate}



\end{document}